<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>B&M Assistant Chat</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <style>
      :root {
        --panel-bg: rgba(255, 255, 255, 0.88);
        --panel-border: rgba(148, 163, 184, 0.35);
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.12);
        --surface: #f5f7fb;
      }

      body {
        background: linear-gradient(135deg, #f8fbff 0%, #eef2ff 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        font-size: 0.95rem;
        color: #0f172a;
      }

      main.container {
        max-width: 860px;
      }

      .shell {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 18px;
        box-shadow: 0 18px 46px rgba(15, 23, 42, 0.08);
        backdrop-filter: blur(10px);
        overflow: hidden;
      }

      .header {
        padding: 20px 24px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(248, 250, 252, 0.65);
      }

      .header h1 {
        font-size: 1.4rem;
        font-weight: 600;
        margin: 0;
        color: #1f2937;
      }

      .header .status {
        background: var(--accent-soft);
        color: var(--accent);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.85rem;
        font-weight: 600;
      }

      .shell section {
        padding: 0;
      }

      .messages { height: 42vh; overflow-y: auto; padding: 18px 22px; display: flex; flex-direction: column; gap: 12px; background: rgba(248, 250, 252, 0.7); }
      .msg { padding: 12px 16px; border-radius: 14px; max-width: 82%; white-space: pre-wrap; line-height: 1.45; font-size: 0.9rem; }
      .user { align-self: flex-end; background: rgba(37, 99, 235, 0.12); border: 1px solid rgba(37, 99, 235, 0.25); color: #1d4ed8; }
      .assistant { align-self: flex-start; background: #ffffff; border: 1px solid rgba(148, 163, 184, 0.3); color: #1e293b; }
      .inputBar { display: flex; gap: 12px; border-top: 1px solid rgba(148, 163, 184, 0.25); padding: 16px 20px; align-items: center; background: rgba(248, 250, 252, 0.8); }
      .inputBar input { flex: 1; padding: 12px 16px; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.45); font-size: 0.95rem; background: #fff; color: #111827; }
      .inputBar input::placeholder { color: rgba(71, 85, 105, 0.8); }
      .inputBar button { padding: 12px 18px; border-radius: 12px; border: none; background: var(--accent); color: white; font-weight: 600; cursor: pointer; box-shadow: 0 12px 18px rgba(37, 99, 235, 0.22); }
      .inputBar button:disabled { opacity: 0.6; cursor: not-allowed; }
      .pill { font-size: 12px; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 999px; }
      .authWrapper { padding: 32px; display: flex; flex-direction: column; gap: 20px; background: rgba(255, 255, 255, 0.85); border-radius: 18px; border: 1px solid rgba(148, 163, 184, 0.25); box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08); }
      .authWrapper h2 { margin: 0; font-size: 20px; font-weight: 600; }
      .authWrapper p { margin: 0; color: #4b5563; font-size: 14px; }
      .authWrapper form { display: flex; flex-direction: column; gap: 12px; }
      .authWrapper label { display: flex; flex-direction: column; gap: 6px; font-size: 14px; color: #111; }
      .authWrapper input { padding: 12px; border-radius: 10px; border: 1px solid #d1d5db; font-size: 16px; }
      .authActions { display: flex; align-items: center; gap: 12px; }
      .authToggle { background: none; border: none; color: #2563eb; cursor: pointer; padding: 0; font-size: 14px; font-weight: 500; }
      .error { color: #dc2626; font-size: 14px; }
      .chatMeta { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid #e6e8eb; font-size: 14px; background: #f9fafb; }
      .chatMeta button { font-size: 14px; }
      .rememberRow { display: flex; align-items: center; gap: 8px; font-size: 14px; color: #111; }
      .rememberRow input { width: 16px; height: 16px; }
      .roleTabs { display: flex; flex-wrap: wrap; gap: 10px; padding: 16px 20px; border-bottom: 1px solid rgba(148, 163, 184, 0.2); background: rgba(248, 250, 252, 0.65); }
      .roleTabs button { border: none; background: rgba(148, 163, 184, 0.18); color: #334155; border-radius: 999px; padding: 8px 16px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s ease; }
      .roleTabs button:hover { background: rgba(37, 99, 235, 0.15); color: #1d4ed8; }
      .roleTabs button.active { background: var(--accent); color: #fff; box-shadow: 0 10px 20px rgba(37, 99, 235, 0.25); }
      .statePanel { padding: 16px 20px; border-bottom: 1px solid rgba(148, 163, 184, 0.2); background: rgba(255, 255, 255, 0.7); display: flex; flex-direction: column; gap: 8px; font-size: 0.92rem; color: #334155; }
      .statePanel strong { font-weight: 600; }
      .practiceControls, .coachControls { padding: 18px 20px; border-bottom: 1px solid rgba(148, 163, 184, 0.2); display: flex; flex-direction: column; gap: 16px; background: rgba(255, 255, 255, 0.85); }
      .practiceRow, .coachRow { display: flex; flex-wrap: wrap; gap: 12px; }
      .practiceRow label, .coachRow label { display: flex; flex-direction: column; gap: 6px; font-size: 14px; color: #1f2933; }
      .practiceRow select, .coachRow input, .coachRow textarea { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(148, 163, 184, 0.45); font-size: 0.9rem; min-width: 180px; background: #f9fafc; color: #1e293b; }
      .coachRow textarea { min-height: 60px; resize: vertical; }
      .practiceActions { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
      .transcriptBox { max-height: 160px; overflow-y: auto; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 12px; padding: 12px; background: rgba(248, 250, 252, 0.9); font-size: 0.88rem; line-height: 1.5; }
      .transcriptBox div { margin-bottom: 4px; }
      .pillButton { border: none; background: rgba(148, 163, 184, 0.25); padding: 8px 14px; border-radius: 999px; font-size: 0.85rem; cursor: pointer; transition: background 0.2s ease; color: #475569; }
      .pillButton:hover { background: rgba(37, 99, 235, 0.18); color: #1d4ed8; }
      .pillButton.danger { color: #b91c1c; background: rgba(248, 113, 113, 0.18); }
      .spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255, 255, 255, 0.3); border-top: 2px solid white; border-radius: 50%; animation: spin 0.8s linear infinite; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .audioControls { display: flex; gap: 12px; align-items: center; padding: 16px 20px; border-top: 1px solid rgba(148, 163, 184, 0.25); background: rgba(248, 250, 252, 0.8); }
      .recordButton { padding: 12px 24px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
      .recordButton.inactive { background: var(--accent); color: white; }
      .recordButton.recording { background: #dc2626; color: white; animation: pulse 1.5s ease-in-out infinite; }
      .recordButton.connecting { background: #fbbf24; color: #78350f; }
      @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <main class="container">
      <article class="shell">
        <header class="header">
          <h1>Business &amp; Mission Studio</h1>
          <span class="status" id="status">Booting…</span>
        </header>
        <section>
          <div id="root"></div>
        </section>
      </article>
    </main>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      const AUTH_COOKIE = 'bm_user';
      const ROLE_DEFS = [
        { id: 'controller', label: 'Home', description: 'Main menu - choose Training, Practice, or Coaching.' },
        { id: 'trainer', label: 'Trainer', description: 'Teach theology, principles, and skills.' },
        { id: 'practicer', label: 'Practicer', description: 'Roleplay real conversations with seekers.' },
        { id: 'coach', label: 'Coach', description: 'Give constructive feedback and next steps.' },
      ];

      const ROLE_MAP = Object.fromEntries(ROLE_DEFS.map(role => [role.id, role]));

      const PRACTICE_SCENARIOS = [
        { value: 'shop_worker', label: 'Shop worker helping you when not busy' },
        { value: 'parent_social', label: 'Another parent at a social event' },
        { value: 'sports_teammate', label: 'Sports teammate at drinks after game/practice' },
        { value: 'taxi_driver', label: 'Taxi/Uber driver on a long drive' },
        { value: 'coworker_mentor', label: 'Coworker seeking mentoring or advice' },
        { value: 'market_stall', label: 'Market stall owner at Farmers Market when not busy' },
        { value: 'neighbor_dog_walk', label: 'Neighbor you meet while walking the dog' },
      ];

      const LIGHT_OPTIONS = [
        { value: 'green_light', label: 'Green Light (open & eager)' },
        { value: 'yellow_light', label: 'Yellow Light (curious but cautious)' },
        { value: 'red_light', label: 'Red Light (resistant)' },
      ];

      function decodeCookieValue(raw) {
        if (!raw) return null;
        try {
          let normalized = raw.replace(/-/g, '+').replace(/_/g, '/');
          while (normalized.length % 4 !== 0) normalized += '=';
          const json = atob(normalized);
          return JSON.parse(json);
        } catch (err) {
          console.warn('Failed to decode remember cookie', err);
          return null;
        }
      }

      function getRememberedUser() {
        if (typeof document === 'undefined') return null;
        const parts = document.cookie.split(';').map(part => part.trim());
        for (const part of parts) {
          if (part.startsWith(`${AUTH_COOKIE}=`)) {
            const value = part.slice(AUTH_COOKIE.length + 1);
            return decodeCookieValue(value);
          }
        }
        return null;
      }

      function ChatApp() {
        const [user, setUser] = useState(null);
        const [authMode, setAuthMode] = useState('login');
        const [authForm, setAuthForm] = useState({ email: 'rob.sturgessdurden@gmail.com', password: 'St33lm4n!', fullName: '' });
        const [authLoading, setAuthLoading] = useState(false);
        const [authError, setAuthError] = useState('');
        const [rememberMe, setRememberMe] = useState(false);

        const [activeRole, setActiveRole] = useState('controller');
        const [messagesByRole, setMessagesByRole] = useState(() => {
          const initial = {};
          ROLE_DEFS.forEach(role => { initial[role.id] = []; });
          return initial;
        });
        const [stateSnapshot, setStateSnapshot] = useState(null);
        const [input, setInput] = useState('');
        const [loading, setLoading] = useState(false);

        const [practiceConfig, setPracticeConfig] = useState({
          scenario: PRACTICE_SCENARIOS[0].value,
          difficulty: 'yellow_light',
          outcome: 'yellow_light',
        });
        const [practiceTranscript, setPracticeTranscript] = useState([]);
        const [practiceCompletedFlag, setPracticeCompletedFlag] = useState(false);
        const [practiceAudioMode, setPracticeAudioMode] = useState(false);
        const [realtimeSession, setRealtimeSession] = useState(null);
        const [isRecording, setIsRecording] = useState(false);
        const [audioStatus, setAudioStatus] = useState('inactive'); // inactive, connecting, ready, recording
        const [vadMode, setVadMode] = useState(true); // Voice Activity Detection mode (always on by default)

        const wsRef = useRef(null);
        const audioContextRef = useRef(null);
        const audioStreamRef = useRef(null);
        const processorRef = useRef(null);
        const audioQueueRef = useRef([]);
        const isPlayingRef = useRef(false);
        const isRecordingRef = useRef(false);
        const recordingStartTimeRef = useRef(null);
        const silenceTimeoutRef = useRef(null);
        const speechDetectedRef = useRef(false);
        const audioSentRef = useRef(false);
        const lastPlaybackEndRef = useRef(0);
        const assistantRespondingRef = useRef(false);

        const [trainerTopic, setTrainerTopic] = useState('');
        const [trainerMarkComplete, setTrainerMarkComplete] = useState(false);
        const [trainerNotes, setTrainerNotes] = useState('');

        const [coachNextSteps, setCoachNextSteps] = useState('');
        const [coachRubric, setCoachRubric] = useState({
          clarity: '',
          listening: '',
          sensitivity: '',
          invitation: '',
        });

        const scrollerRef = useRef(null);

        const activeRoleDef = ROLE_MAP[activeRole] || ROLE_DEFS[0];

        useEffect(() => {
          console.log('Checking for remembered user...');
          console.log('Document cookies:', document.cookie);
          const remembered = getRememberedUser();
          console.log('Remembered user:', remembered);
          if (remembered && remembered.email) {
            console.log('Auto-logging in as:', remembered.email);
            setUser({ email: remembered.email, full_name: remembered.full_name || '' });
            setRememberMe(true);
          }
        }, []);

        useEffect(() => {
          const pill = document.getElementById('status');
          if (!pill) return;
          if (!user) {
            pill.textContent = 'Sign in required';
            return;
          }
          if (loading) {
            pill.textContent = 'Working…';
            return;
          }
          pill.textContent = `${activeRoleDef.label} ready`;
        }, [user, loading, activeRoleDef]);

        useEffect(() => {
          if (scrollerRef.current) {
            const messages = messagesByRole[activeRole] || [];
            if (messages.length > 0) {
              // Scroll to show the start of the most recent message
              const lastMessage = scrollerRef.current.lastElementChild;
              if (lastMessage) {
                lastMessage.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }
          }
        }, [messagesByRole, activeRole]);

        // Cleanup audio resources when leaving practicer or unmounting
        useEffect(() => {
          return () => {
            if (wsRef.current) {
              wsRef.current.close();
              wsRef.current = null;
            }
            stopAudioCapture();
          };
        }, []);

        // Stop audio when switching away from practicer
        useEffect(() => {
          if (activeRole !== 'practicer' && practiceAudioMode) {
            setPracticeAudioMode(false);
            stopRealtimeSession();
          }
        }, [activeRole]);

        useEffect(() => {
          if (!user) {
            resetSessionState();
            return;
          }

          const firstName = (() => {
            if (user.full_name && user.full_name.trim()) {
              return user.full_name.trim().split(' ')[0];
            }
            return user.email.split('@')[0];
          })();

          const initialMessages = {};
          ROLE_DEFS.forEach(role => { initialMessages[role.id] = []; });
          initialMessages.controller = [
            { role: 'assistant', content: `Hi ${firstName}! Welcome to Business & Mission Studio.\n\nClick one of the tabs above to get started:\n• Trainer - Learn theology and evangelism skills\n• Practicer - Practice conversations in realistic scenarios\n• Coach - Get feedback on your practice sessions` }
          ];

          resetSessionState(initialMessages);
          setActiveRole('controller');

          // Just refresh state, don't call the agent
          (async () => {
            await refreshState(user.email);
          })();
        }, [user?.email]);

        function resetSessionState(initialMessages) {
          setMessagesByRole(() => {
            if (initialMessages) {
              return initialMessages;
            }
            const initial = {};
            ROLE_DEFS.forEach(role => { initial[role.id] = []; });
            return initial;
          });
          setStateSnapshot(null);
          setPracticeTranscript([]);
          setPracticeCompletedFlag(false);
          setCoachNextSteps('');
          setCoachRubric({ clarity: '', listening: '', sensitivity: '', invitation: '' });
          setTrainerTopic('');
          setTrainerNotes('');
          setTrainerMarkComplete(false);
          setPracticeConfig({
            scenario: PRACTICE_SCENARIOS[0].value,
            difficulty: 'yellow_light',
            outcome: 'yellow_light',
          });
        }

        async function refreshState(userId) {
          if (!userId) return;
          try {
            const res = await fetch(`/api/agent/state?user_id=${encodeURIComponent(userId)}`, { credentials: 'same-origin' });
            if (!res.ok) return;
            const data = await res.json().catch(() => null);
            if (data && data.state) {
              setStateSnapshot(data.state);
            }
          } catch (err) {
            console.warn('Failed to refresh state', err);
          }
        }

        async function handleAuthSubmit(event) {
          event.preventDefault();
          if (authLoading) return;

          const email = authForm.email.trim().toLowerCase();
          const password = authForm.password;
          const fullName = authForm.fullName.trim();

          if (!email || !password) {
            setAuthError('Email and password are required.');
            return;
          }
          if (authMode === 'register' && password.length < 8) {
            setAuthError('Password must be at least 8 characters long.');
            return;
          }

          setAuthLoading(true);
          setAuthError('');

          const endpoint = authMode === 'register' ? '/api/register' : '/api/login';
          const payload = { email, password };
          if (authMode === 'register') {
            payload.full_name = fullName;
          }
          if (authMode === 'login') {
            payload.remember_me = rememberMe;
          }

          try {
            const res = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify(payload)
            });

            const result = await res.json().catch(() => ({}));
            if (!res.ok) {
              const detail = result.detail || 'Authentication failed. Please try again.';
              throw new Error(detail);
            }

            setUser({ email: result.email, full_name: result.full_name });
            setAuthForm({ email: '', password: '', fullName: '' });
            setRememberMe(authMode === 'login' ? rememberMe : false);
          } catch (err) {
            setAuthError(err.message || 'Authentication failed.');
          } finally {
            setAuthLoading(false);
          }
        }

        function handleToggleMode() {
          setAuthMode(prev => prev === 'login' ? 'register' : 'login');
          setAuthError('');
          if (authMode === 'login') {
            setRememberMe(false);
          }
        }

        async function handleLogout() {
          try {
            await fetch('/api/logout', { method: 'POST', credentials: 'same-origin' });
          } catch (err) {
            console.warn('Logout request failed', err);
          }
          setUser(null);
          setInput('');
          setRememberMe(false);
          resetSessionState();
          setActiveRole('controller');
        }

        function formatRole(role) {
          if (!role) return '';
          if (role === 'user') return 'You';
          if (role === 'assistant' || role === 'bot') return 'Agent';
          return role.charAt(0).toUpperCase() + role.slice(1);
        }

        function handlePracticeConfigChange(key, value) {
          setPracticeConfig(prev => ({ ...prev, [key]: value }));
          if (key === 'scenario') {
            resetPracticeSession();
          }
        }

        function resetPracticeSession() {
          setPracticeTranscript([]);
          setPracticeCompletedFlag(false);
          setMessagesByRole(prev => ({ ...prev, practicer: [] }));
        }

        async function runAgentMessage(roleId, message, options = {}) {
          if (!user) return;
          const outgoing = typeof message === 'string' ? message : '';
          const trimmed = outgoing.trim();
          const skipUserEcho = options.skipUserEcho || false;
          const displayText = trimmed || outgoing;
          if (!skipUserEcho && !displayText) {
            return;
          }

          if (!skipUserEcho) {
            setMessagesByRole(prev => ({
              ...prev,
              [roleId]: [...prev[roleId], { role: 'user', content: displayText }]
            }));
          }

          setLoading(true);

          try {
            let endpoint = '';
            let body = {};

            if (roleId === 'controller') {
              endpoint = '/api/agent/controller';
              body = { user_id: user.email, message: displayText };
            } else if (roleId === 'trainer') {
              endpoint = '/api/agent/trainer';
              body = {
                user_id: user.email,
                message: displayText,
                topic: trainerTopic || undefined,
                mark_complete: trainerMarkComplete || undefined,
                notes: trainerNotes || undefined,
              };
            } else if (roleId === 'practicer') {
              if (!displayText) {
                setLoading(false);
                return;
              }
              endpoint = '/api/agent/practicer';
              body = {
                user_id: user.email,
                message: displayText,
                scenario: practiceConfig.scenario,
                difficulty: practiceConfig.difficulty,
                outcome: practiceConfig.outcome,
                transcript: practiceTranscript,
                session_completed: options.sessionCompletedFlag ?? practiceCompletedFlag,
              };
            } else if (roleId === 'coach') {
              if (!practiceTranscript.length) {
                throw new Error('Run a practice session before requesting coaching feedback.');
              }
              endpoint = '/api/agent/coach';
              const rubricPayload = Object.entries(coachRubric).reduce((acc, [key, value]) => {
                if (value && value.trim()) {
                  acc[key] = value.trim();
                }
                return acc;
              }, {});
              const previous = (stateSnapshot?.coaching_feedback || []).map(item => item.feedback).filter(Boolean);
              body = {
                user_id: user.email,
                message: displayText,
                transcript: practiceTranscript,
                previous_feedback: previous,
                rubric: Object.keys(rubricPayload).length ? rubricPayload : undefined,
                next_steps: coachNextSteps || undefined,
              };
            } else {
              endpoint = '/api/chat';
              body = { user_id: user.email, message: displayText };
            }

            const res = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify(body)
            });

            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
              const detail = data.detail || `HTTP ${res.status}`;
              throw new Error(detail);
            }

            const assistantText = data.reply || 'No response received.';
            setMessagesByRole(prev => ({
              ...prev,
              [roleId]: [...prev[roleId], { role: 'assistant', content: assistantText }]
            }));

            if (data.state) {
              setStateSnapshot(data.state);
            }

            if (roleId === 'controller') {
              const routeTo = data.metadata && data.metadata.route_to;
              if (routeTo && ROLE_MAP[routeTo]) {
                setActiveRole(routeTo);
                setMessagesByRole(prev => {
                  const currentMessages = prev[routeTo] || [];
                  if (currentMessages.length > 0) {
                    return prev;
                  }
                  return {
                    ...prev,
                    [routeTo]: [{
                      role: 'assistant',
                      content: `${ROLE_MAP[routeTo].label} ready. Let me know how to proceed.`,
                    }],
                  };
                });
              }
            }

            if (data.state?.current_role && ROLE_MAP[data.state.current_role]) {
              const preferredRole = data.state.current_role;
              if (preferredRole !== activeRole) {
                setActiveRole(preferredRole);
                setMessagesByRole(prev => {
                  const currentMessages = prev[preferredRole] || [];
                  if (currentMessages.length === 0) {
                    return {
                      ...prev,
                      [preferredRole]: [{
                        role: 'assistant',
                        content: `${ROLE_MAP[preferredRole].label} ready when you are.`,
                      }],
                    };
                  }
                  return prev;
                });
              }
            }

            if (roleId === 'trainer' && trainerMarkComplete) {
              setTrainerMarkComplete(false);
            }

            if (roleId === 'practicer') {
              const transcriptMeta = (data.metadata && data.metadata.transcript) || [
                ...practiceTranscript,
                { role: 'user', content: displayText },
                { role: 'assistant', content: assistantText }
              ];
              const normalizedTranscript = transcriptMeta.map(turn => ({
                role: turn.role === 'bot' ? 'assistant' : turn.role,
                content: turn.content,
              }));
              setPracticeTranscript(normalizedTranscript);
              if (options.sessionCompletedFlag || data.metadata?.session_completed) {
                setPracticeCompletedFlag(false);
              }
            }

            if (roleId === 'coach' && coachNextSteps) {
              setCoachNextSteps('');
            }
          } catch (err) {
            setMessagesByRole(prev => ({
              ...prev,
              [roleId]: [...prev[roleId], { role: 'assistant', content: `Error: ${err.message}` }]
            }));
          } finally {
            setLoading(false);
          }
        }

        async function handleSend() {
          const content = input.trim();
          if (!content) return;
          if (activeRole === 'practicer') {
            await runAgentMessage('practicer', content, { sessionCompletedFlag: practiceCompletedFlag });
          } else {
            await runAgentMessage(activeRole, content);
          }
          setInput('');
        }

        function onKeyDown(e) {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSend();
          }
        }

        function renderRoleTabs() {
          return (
            <div className="roleTabs">
              {ROLE_DEFS.map(role => (
                <button
                  key={role.id}
                  className={activeRole === role.id ? 'active' : ''}
                  onClick={() => {
                    setActiveRole(role.id);
                    setInput('');
                  }}
                  disabled={loading && activeRole === role.id}
                >
                  {role.label}
                </button>
              ))}
            </div>
          );
        }

        function renderStateSummary() {
          const training = stateSnapshot?.training_progress || {};
          const completedTopics = Array.isArray(training.completed_topics) ? training.completed_topics : [];
          const practiceHistory = stateSnapshot?.practice_history || [];
          const coachingHistory = stateSnapshot?.coaching_feedback || [];
          return (
            <div className="statePanel">
              <div><strong>{activeRoleDef.label}</strong>: {activeRoleDef.description}</div>
              <div><strong>Training:</strong> {completedTopics.length ? completedTopics.join(', ') : 'No topics completed yet.'}</div>
              <div><strong>In progress:</strong> {training.in_progress_topic || 'None'}</div>
              {training.notes ? <div><strong>Notes:</strong> {training.notes}</div> : null}
              {practiceHistory.length > 0 ? (
                <div>
                  <strong>Last practice:</strong> {practiceHistory[practiceHistory.length - 1].scenario || 'Unknown'} · {practiceHistory[practiceHistory.length - 1].difficulty || 'n/a'} · Outcome {practiceHistory[practiceHistory.length - 1].outcome || 'n/a'}
                </div>
              ) : null}
              {coachingHistory.length > 0 ? (
                <div><strong>Latest coaching:</strong> {coachingHistory[coachingHistory.length - 1].feedback}</div>
              ) : null}
            </div>
          );
        }

        function renderTrainerControls() {
          const trainingTopics = [
            { value: '1', label: '1. Theology behind effective outreach' },
            { value: '2', label: '2. Key principles about people far from God' },
            { value: '3', label: '3. Go-to skills for conversations' },
            { value: '4', label: '4. Dos and don\'ts' },
          ];

          return (
            <div className="practiceControls">
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                <div style={{ fontSize: '13px', fontWeight: '600', color: '#1f2937' }}>Quick select training topic:</div>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                  {trainingTopics.map(topic => (
                    <button
                      key={topic.value}
                      type="button"
                      className="pillButton"
                      onClick={async () => {
                        setTrainerTopic(topic.value);
                        await runAgentMessage('trainer', topic.label);
                      }}
                      disabled={loading}
                      style={{ background: trainerTopic === topic.value ? 'rgba(37, 99, 235, 0.18)' : undefined, color: trainerTopic === topic.value ? '#1d4ed8' : undefined }}
                    >
                      {topic.label}
                    </button>
                  ))}
                </div>
              </div>
              <div className="coachRow">
                <label className="rememberRow">
                  <input
                    type="checkbox"
                    checked={trainerMarkComplete}
                    onChange={e => setTrainerMarkComplete(e.target.checked)}
                  />
                  Mark topic complete after this response
                </label>
              </div>
            </div>
          );
        }

        async function startRealtimeSession() {
          try {
            setAudioStatus('connecting');

            // Create realtime session
            const res = await fetch('/api/realtime/session', {
              method: 'POST',
              credentials: 'same-origin'
            });
            const data = await res.json();
            if (!res.ok) {
              throw new Error(data.detail || 'Failed to create realtime session');
            }
            console.log('Realtime session created:', data);
            setRealtimeSession(data);

            if (!data.api_key) {
              throw new Error('No API key in session response');
            }

            // Connect WebSocket using the API key in the Authorization header via subprotocol
            const wsUrl = `wss://api.openai.com/v1/realtime?model=${encodeURIComponent(data.model)}`;
            console.log('Connecting to WebSocket:', wsUrl);

            // Try connecting with Authorization header via custom header (not possible in browser)
            // We need to use the protocol-based auth
            const ws = new WebSocket(wsUrl, [
              'realtime',
              `openai-insecure-api-key.${data.api_key}`,
              `openai-beta.realtime-v1`
            ]);
            wsRef.current = ws;

            // Add connection timeout
            let timeoutTriggered = false;
            const connectionTimeout = setTimeout(() => {
              if (wsRef.current && wsRef.current.readyState !== WebSocket.OPEN) {
                console.error('WebSocket connection timeout');
                timeoutTriggered = true;
                if (wsRef.current) {
                  wsRef.current.close();
                }
                setAudioStatus('inactive');
                setPracticeAudioMode(false);
                alert('Audio connection timed out. Please try again.');
              }
            }, 10000); // 10 second timeout

            ws.onopen = async () => {
              console.log('WebSocket onopen fired');
              if (timeoutTriggered) {
                console.log('Timeout already triggered, aborting onopen');
                return;
              }
              console.log('WebSocket connected, ready state:', ws.readyState);
              clearTimeout(connectionTimeout);

              // Start audio capture first
              try {
                console.log('Starting audio capture...');
                await startAudioCapture(ws);
                console.log('Audio capture started successfully, setting status to ready');
                setAudioStatus('ready');
              } catch (err) {
                console.error('Failed to start audio capture:', err);
                alert('Failed to access microphone: ' + err.message);
                setAudioStatus('inactive');
                setPracticeAudioMode(false);
                ws.close();
                return;
              }

              // Send session update with instructions
              console.log('Sending session.update...');
              const scenarioLabel = PRACTICE_SCENARIOS.find(s => s.value === practiceConfig.scenario)?.label || practiceConfig.scenario;
              const difficultyLabel = LIGHT_OPTIONS.find(d => d.value === practiceConfig.difficulty)?.label || practiceConfig.difficulty;
              const outcomeLabel = LIGHT_OPTIONS.find(o => o.value === practiceConfig.outcome)?.label || practiceConfig.outcome;

              ws.send(JSON.stringify({
                type: 'session.update',
                session: {
                  instructions: `You are a conversation simulator designed to help users practice talking about Christianity in everyday life. You are roleplaying as someone without faith and the user is trying to encourage you to discuss faith and spirituality.

Scenario: ${scenarioLabel}
Difficulty level: ${difficultyLabel}
Target outcome: ${outcomeLabel}

Stay in character and respond naturally as this person would. Start the conversation by greeting the user and introducing yourself in character. Be realistic in your responses - show curiosity, resistance, or openness based on the difficulty level. Remember, you are NOT a Christian and are exploring these topics with varying levels of interest depending on the difficulty setting.

IMPORTANT: When the user says "End," or when the session naturally closes:
1. Step out of character
2. Switch into coach mode
3. Give structured feedback covering:
   - What went well in the conversation
   - Areas for improvement
   - Specific suggestions for next time
   - How well they adapted to the difficulty level
   - Overall assessment of their approach`
                }
              }));

              // Send initial greeting request
              console.log('Sending response.create for initial greeting...');
              ws.send(JSON.stringify({
                type: 'response.create'
              }));
            };

            ws.onmessage = async (event) => {
              const message = JSON.parse(event.data);
              console.log('Received:', message.type);

              if (message.type === 'error') {
                console.error('WebSocket error message:', message);
                alert('Audio session error: ' + (message.error?.message || JSON.stringify(message)));
                setAudioStatus('inactive');
                setPracticeAudioMode(false);
                ws.close();
                return;
              }

              // Track when assistant starts/stops responding
              if (message.type === 'response.created' || message.type === 'response.audio.delta') {
                assistantRespondingRef.current = true;
              } else if (message.type === 'response.done') {
                assistantRespondingRef.current = false;
              }

              if (message.type === 'response.audio.delta' && message.delta) {
                // Queue audio for playback
                audioQueueRef.current.push(message.delta);
                if (!isPlayingRef.current) {
                  playAudioQueue();
                }
              } else if (message.type === 'response.audio_transcript.delta' && message.delta) {
                // Update transcript
                setPracticeTranscript(prev => {
                  const last = prev[prev.length - 1];
                  if (last && last.role === 'assistant' && !last.completed) {
                    return [...prev.slice(0, -1), { ...last, content: last.content + message.delta }];
                  } else {
                    return [...prev, { role: 'assistant', content: message.delta, completed: false }];
                  }
                });
              } else if (message.type === 'response.audio_transcript.done') {
                setPracticeTranscript(prev => {
                  const last = prev[prev.length - 1];
                  if (last && last.role === 'assistant') {
                    return [...prev.slice(0, -1), { ...last, completed: true }];
                  }
                  return prev;
                });
              } else if (message.type === 'input_audio_buffer.speech_started') {
                setIsRecording(true);
              } else if (message.type === 'input_audio_buffer.speech_stopped') {
                setIsRecording(false);
              } else if (message.type === 'conversation.item.input_audio_transcription.completed') {
                setPracticeTranscript(prev => [...prev, { role: 'user', content: message.transcript, completed: true }]);
              }
            };

            ws.onerror = (error) => {
              console.error('WebSocket error:', error);
              clearTimeout(connectionTimeout);
              setAudioStatus('inactive');
            };

            ws.onclose = () => {
              console.log('WebSocket closed');
              clearTimeout(connectionTimeout);
              setAudioStatus('inactive');
              stopAudioCapture();
            };

          } catch (err) {
            console.error('Failed to start realtime session:', err);
            alert('Failed to start audio mode: ' + err.message);
            setPracticeAudioMode(false);
            setAudioStatus('inactive');
          }
        }

        async function startAudioCapture(ws) {
          try {
            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
              throw new Error('Microphone access is not available. Please use HTTPS or localhost.');
            }

            // Request audio with echo cancellation, noise suppression, and auto gain control
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              }
            });
            audioStreamRef.current = stream;

            const audioContext = new AudioContext({ sampleRate: 24000 });
            audioContextRef.current = audioContext;

            const source = audioContext.createMediaStreamSource(stream);
            const processor = audioContext.createScriptProcessor(4096, 1, 1);
            processorRef.current = processor;

            processor.onaudioprocess = (e) => {
              if (ws.readyState !== WebSocket.OPEN) return;

              const inputData = e.inputBuffer.getChannelData(0);

              // Calculate volume level for VAD
              let sum = 0;
              for (let i = 0; i < inputData.length; i++) {
                sum += inputData[i] * inputData[i];
              }
              const rms = Math.sqrt(sum / inputData.length);
              const volume = Math.max(0, Math.min(1, rms * 10)); // Normalize and boost

              // Voice Activity Detection threshold
              const SPEECH_THRESHOLD = 0.05; // Increased from 0.02 - adjust if still too sensitive (0.01-0.10 typical range)
              const SILENCE_DURATION = 1500; // 1.5 seconds of silence before auto-send
              const PLAYBACK_BUFFER = 500; // Wait 500ms after playback ends before detecting speech again
              const MIN_RECORDING_DURATION = 300; // Minimum 300ms of continuous recording before allowing commit

              // Don't detect speech while assistant is playing audio, responding, or shortly after
              const timeSincePlayback = Date.now() - lastPlaybackEndRef.current;
              const isSpeaking = volume > SPEECH_THRESHOLD &&
                                !isPlayingRef.current &&
                                !assistantRespondingRef.current &&
                                timeSincePlayback > PLAYBACK_BUFFER;

              if (vadMode) {
                // Automatic VAD mode
                if (isSpeaking) {
                  // Start recording if not already
                  if (!isRecordingRef.current) {
                    console.log('✓ Speech detected, starting recording (volume:', volume.toFixed(3), ')');
                    isRecordingRef.current = true;
                    setIsRecording(true);
                    speechDetectedRef.current = true;
                    audioSentRef.current = false;
                    recordingStartTimeRef.current = Date.now();
                  }

                  // Clear any silence timeout
                  if (silenceTimeoutRef.current) {
                    clearTimeout(silenceTimeoutRef.current);
                    silenceTimeoutRef.current = null;
                  }
                } else if (isRecordingRef.current && speechDetectedRef.current) {
                  // Detected silence while recording
                  if (!silenceTimeoutRef.current) {
                    console.log('Silence detected, starting timer...');
                    // Start silence timer
                    silenceTimeoutRef.current = setTimeout(() => {
                      // Auto-commit after silence - only if we actually sent audio
                      const recordingDuration = Date.now() - (recordingStartTimeRef.current || 0);
                      console.log(`⏱️  Auto-commit timer fired: duration=${recordingDuration}ms, audioSent=${audioSentRef.current}, assistantResponding=${assistantRespondingRef.current}`);

                      // Only commit if we sent actual audio data, recording was long enough, AND assistant is not currently responding
                      if (recordingDuration >= MIN_RECORDING_DURATION && audioSentRef.current && !assistantRespondingRef.current) {
                        console.log('✓ Committing audio buffer and requesting response');
                        ws.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                        ws.send(JSON.stringify({ type: 'response.create' }));
                      } else {
                        console.log(`✗ Skipping commit - duration=${recordingDuration}ms, audioSent=${audioSentRef.current}, assistantResponding=${assistantRespondingRef.current}`);
                      }

                      isRecordingRef.current = false;
                      setIsRecording(false);
                      speechDetectedRef.current = false;
                      audioSentRef.current = false;
                      recordingStartTimeRef.current = null;
                      silenceTimeoutRef.current = null;
                    }, SILENCE_DURATION);
                  }
                }
              }

              // Send audio data when recording (both VAD and manual modes)
              if (isRecordingRef.current) {
                const pcm16 = new Int16Array(inputData.length);
                for (let i = 0; i < inputData.length; i++) {
                  pcm16[i] = Math.max(-32768, Math.min(32767, Math.floor(inputData[i] * 32768)));
                }
                const base64 = btoa(String.fromCharCode(...new Uint8Array(pcm16.buffer)));
                ws.send(JSON.stringify({
                  type: 'input_audio_buffer.append',
                  audio: base64
                }));
                // Mark that we've sent audio data
                audioSentRef.current = true;
              }
            };

            source.connect(processor);
            processor.connect(audioContext.destination);

            // Start in recording mode if VAD is enabled
            if (vadMode) {
              isRecordingRef.current = false; // Will be set to true when speech detected
              setIsRecording(false);
            }
          } catch (err) {
            console.error('Failed to start audio capture:', err);
            throw err;
          }
        }

        function toggleRecording() {
          if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
            return;
          }

          if (isRecordingRef.current) {
            // Check minimum recording time (100ms minimum required by API)
            const recordingDuration = Date.now() - (recordingStartTimeRef.current || 0);

            // Always reset the recording state, even if too short
            isRecordingRef.current = false;
            setIsRecording(false);
            recordingStartTimeRef.current = null;

            // Only commit if we have enough audio and actually sent data (200ms minimum to be safe)
            if (recordingDuration < 200 || !audioSentRef.current) {
              console.log(`Recording too short (${recordingDuration}ms) or no audio sent, not committing`);
              audioSentRef.current = false;
              return;
            }

            wsRef.current.send(JSON.stringify({
              type: 'input_audio_buffer.commit'
            }));
            wsRef.current.send(JSON.stringify({
              type: 'response.create'
            }));
            audioSentRef.current = false;
          } else {
            // Start recording
            isRecordingRef.current = true;
            setIsRecording(true);
            audioSentRef.current = false;
            recordingStartTimeRef.current = Date.now();
          }
        }

        function stopAudioCapture() {
          // Clear any pending silence timeout
          if (silenceTimeoutRef.current) {
            clearTimeout(silenceTimeoutRef.current);
            silenceTimeoutRef.current = null;
          }

          if (processorRef.current) {
            processorRef.current.disconnect();
            processorRef.current = null;
          }
          if (audioStreamRef.current) {
            audioStreamRef.current.getTracks().forEach(track => track.stop());
            audioStreamRef.current = null;
          }
          if (audioContextRef.current) {
            audioContextRef.current.close();
            audioContextRef.current = null;
          }

          isRecordingRef.current = false;
          speechDetectedRef.current = false;
          audioSentRef.current = false;
          recordingStartTimeRef.current = null;
          lastPlaybackEndRef.current = 0;
          assistantRespondingRef.current = false;
        }

        async function playAudioQueue() {
          isPlayingRef.current = true;
          const audioContext = new AudioContext({ sampleRate: 24000 });

          while (audioQueueRef.current.length > 0) {
            const base64Audio = audioQueueRef.current.shift();
            try {
              const binaryString = atob(base64Audio);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              const pcm16 = new Int16Array(bytes.buffer);
              const float32 = new Float32Array(pcm16.length);
              for (let i = 0; i < pcm16.length; i++) {
                float32[i] = pcm16[i] / 32768;
              }
              const audioBuffer = audioContext.createBuffer(1, float32.length, 24000);
              audioBuffer.getChannelData(0).set(float32);

              const source = audioContext.createBufferSource();
              source.buffer = audioBuffer;
              source.connect(audioContext.destination);
              source.start();

              await new Promise(resolve => {
                source.onended = resolve;
              });
            } catch (err) {
              console.error('Error playing audio:', err);
            }
          }

          isPlayingRef.current = false;
          // Mark when playback ended to add buffer time
          lastPlaybackEndRef.current = Date.now();
        }

        function stopRealtimeSession() {
          if (wsRef.current) {
            wsRef.current.close();
            wsRef.current = null;
          }
          stopAudioCapture();
          setRealtimeSession(null);
          setAudioStatus('inactive');
          isRecordingRef.current = false;
          setIsRecording(false);
          audioQueueRef.current = [];
        }

        function renderPracticeControls() {
          return (
            <div className="practiceControls">
              <div className="practiceRow">
                <label>
                  Scenario
                  <select
                    value={practiceConfig.scenario}
                    onChange={e => handlePracticeConfigChange('scenario', e.target.value)}
                  >
                    {PRACTICE_SCENARIOS.map(option => (
                      <option key={option.value} value={option.value}>{option.label}</option>
                    ))}
                  </select>
                </label>
                <label>
                  Difficulty
                  <select
                    value={practiceConfig.difficulty}
                    onChange={e => handlePracticeConfigChange('difficulty', e.target.value)}
                  >
                    {LIGHT_OPTIONS.map(option => (
                      <option key={option.value} value={option.value}>{option.label}</option>
                    ))}
                  </select>
                </label>
                <label>
                  Target outcome
                  <select
                    value={practiceConfig.outcome}
                    onChange={e => handlePracticeConfigChange('outcome', e.target.value)}
                  >
                    {LIGHT_OPTIONS.map(option => (
                      <option key={option.value} value={option.value}>{option.label}</option>
                    ))}
                  </select>
                </label>
              </div>
              <div className="practiceActions">
                <label className="rememberRow">
                  <input
                    type="checkbox"
                    checked={practiceAudioMode}
                    disabled={audioStatus === 'connecting'}
                    onChange={async (e) => {
                      const isChecked = e.target.checked;
                      if (isChecked) {
                        setPracticeAudioMode(true);
                        await startRealtimeSession();
                      } else {
                        setPracticeAudioMode(false);
                        stopRealtimeSession();
                      }
                    }}
                  />
                  Audio mode (realtime voice chat)
                </label>
                {practiceAudioMode && (
                  <label className="rememberRow">
                    <input
                      type="checkbox"
                      checked={vadMode}
                      onChange={e => setVadMode(e.target.checked)}
                    />
                    Auto-detect voice (recommended)
                  </label>
                )}
                <label className="rememberRow">
                  <input
                    type="checkbox"
                    checked={practiceCompletedFlag}
                    onChange={e => setPracticeCompletedFlag(e.target.checked)}
                  />
                  Mark session complete on next response
                </label>
                <button type="button" className="pillButton danger" onClick={resetPracticeSession}>
                  Reset practice transcript
                </button>
              </div>
            </div>
          );
        }

        function renderCoachControls() {
          const previous = (stateSnapshot?.coaching_feedback || []).slice(-3);
          return (
            <div className="coachControls">
              <div className="coachRow">
                <label>
                  Next steps suggestion
                  <input
                    value={coachNextSteps}
                    onChange={e => setCoachNextSteps(e.target.value)}
                    placeholder="Optional note"
                  />
                </label>
              </div>
              <div className="coachRow">
                {Object.keys(coachRubric).map(key => (
                  <label key={key} style={{ flex: '1 1 200px' }}>
                    {key.charAt(0).toUpperCase() + key.slice(1)}
                    <textarea
                      value={coachRubric[key]}
                      onChange={e => setCoachRubric(prev => ({ ...prev, [key]: e.target.value }))}
                      placeholder="Optional notes"
                    />
                  </label>
                ))}
              </div>
              <div>
                <strong style={{ fontSize: '13px' }}>Practice transcript</strong>
                <div className="transcriptBox">
                  {practiceTranscript.length ? practiceTranscript.map((turn, idx) => (
                    <div key={idx}><strong>{formatRole(turn.role)}:</strong> {turn.content}</div>
                  )) : <div>No practice transcript yet. Run a practice session first.</div>}
                </div>
              </div>
              {previous.length > 0 && (
                <div className="transcriptBox" style={{ background: '#eef2ff' }}>
                  <strong style={{ fontSize: '13px' }}>Recent feedback</strong>
                  {previous.map((item, idx) => (
                    <div key={idx}>{item.feedback}</div>
                  ))}
                </div>
              )}
            </div>
          );
        }

        if (!user) {
          return (
            <div className="authWrapper">
              <h2>{authMode === 'login' ? 'Sign in to continue' : 'Create your account'}</h2>
              <p>We log registrations and chat activity to the shared Google Sheet you configured.</p>
              <form onSubmit={handleAuthSubmit}>
                {authMode === 'register' && (
                  <label>
                    Full name (optional)
                    <input
                      type="text"
                      name="fullName"
                      value={authForm.fullName}
                      onChange={e => setAuthForm(prev => ({ ...prev, fullName: e.target.value }))}
                      placeholder="e.g. Alex Smith"
                      autoComplete="name"
                    />
                  </label>
                )}
                <label>
                  Email
                  <input
                    type="email"
                    name="email"
                    value={authForm.email}
                    onChange={e => setAuthForm(prev => ({ ...prev, email: e.target.value }))}
                    placeholder="you@example.com"
                    autoComplete="email"
                    required
                  />
                </label>
                <label>
                  Password
                  <input
                    type="password"
                    name="password"
                    value={authForm.password}
                    onChange={e => setAuthForm(prev => ({ ...prev, password: e.target.value }))}
                    placeholder="Minimum 8 characters"
                    autoComplete={authMode === 'login' ? 'current-password' : 'new-password'}
                    required
                  />
                </label>
                {authMode === 'login' && (
                  <label className="rememberRow">
                    <input
                      type="checkbox"
                      checked={rememberMe}
                      onChange={e => setRememberMe(e.target.checked)}
                    />
                    Remember me
                  </label>
                )}
                {authError && <div className="error">{authError}</div>}
                <div className="authActions">
                  <button type="submit" disabled={authLoading}>
                    {authLoading ? 'Please wait…' : (authMode === 'register' ? 'Register' : 'Sign in')}
                  </button>
                  <button type="button" className="authToggle" onClick={handleToggleMode}>
                    {authMode === 'login' ? 'Need an account? Register →' : 'Have an account? Sign in →'}
                  </button>
                </div>
              </form>
            </div>
          );
        }

        const activeMessages = messagesByRole[activeRole] || [];

        return (
          <>
            <div className="chatMeta">
              <div>Signed in as {(user.full_name && user.full_name.trim()) || user.email}</div>
              <button className="secondary" onClick={handleLogout}>Log out</button>
            </div>
            {renderRoleTabs()}
            {renderStateSummary()}
            {activeRole === 'trainer' && renderTrainerControls()}
            {activeRole === 'practicer' && renderPracticeControls()}
            {activeRole === 'coach' && renderCoachControls()}
            <div className="messages" ref={scrollerRef}>
              {activeMessages.length === 0 ? (
                <div className="msg assistant">Start the conversation with the {activeRoleDef.label.toLowerCase()}.</div>
              ) : activeMessages.map((m, idx) => (
                <div key={idx} className={`msg ${m.role === 'user' ? 'user' : 'assistant'}`}>
                  {m.content}
                </div>
              ))}
            </div>
            {activeRole === 'practicer' && practiceAudioMode ? (
              <div className="audioControls">
                {vadMode ? (
                  // Voice Activity Detection mode - shows status only
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px', width: '100%' }}>
                    <div style={{
                      padding: '12px 24px',
                      borderRadius: '12px',
                      fontWeight: '600',
                      background: audioStatus === 'connecting' ? '#fbbf24' :
                                 isRecording ? '#dc2626' : '#10b981',
                      color: 'white',
                      animation: isRecording ? 'pulse 1.5s ease-in-out infinite' : 'none'
                    }}>
                      {audioStatus === 'connecting' ? '⏳ Connecting...' :
                       isRecording ? '🎤 Recording...' : '👂 Listening...'}
                    </div>
                    <div style={{ fontSize: '14px', color: '#64748b', flex: 1 }}>
                      {audioStatus === 'connecting' ? 'Setting up audio connection...' :
                       isRecording ? 'Speaking detected - will auto-send after you stop' :
                       audioStatus === 'ready' ? 'Listening for your voice - just start talking! Say "End" when finished to get feedback.' :
                       'Waiting for connection...'}
                    </div>
                  </div>
                ) : (
                  // Manual push-to-talk mode
                  <>
                    <button
                      className={`recordButton ${audioStatus === 'connecting' ? 'connecting' : isRecording ? 'recording' : 'inactive'}`}
                      disabled={audioStatus === 'inactive' || audioStatus === 'connecting'}
                      onMouseDown={(e) => {
                        e.preventDefault();
                        if (audioStatus === 'ready' && !isRecording) {
                          isRecordingRef.current = true;
                          setIsRecording(true);
                          recordingStartTimeRef.current = Date.now();
                        }
                      }}
                      onMouseUp={(e) => {
                        e.preventDefault();
                        if (audioStatus === 'ready' && isRecording) {
                          toggleRecording();
                        }
                      }}
                      onTouchStart={(e) => {
                        e.preventDefault();
                        if (audioStatus === 'ready' && !isRecording) {
                          isRecordingRef.current = true;
                          setIsRecording(true);
                          recordingStartTimeRef.current = Date.now();
                        }
                      }}
                      onTouchEnd={(e) => {
                        e.preventDefault();
                        if (audioStatus === 'ready' && isRecording) {
                          toggleRecording();
                        }
                      }}
                    >
                      {audioStatus === 'connecting' ? 'Connecting...' : isRecording ? '🎤 Recording...' : '🎤 Hold to Talk'}
                    </button>
                    <div style={{ fontSize: '14px', color: '#64748b' }}>
                      {audioStatus === 'ready' && isRecording ? 'Release to send your message' :
                       audioStatus === 'ready' ? 'Hold the button and speak - release when done. Say "End" to get feedback.' :
                       audioStatus === 'connecting' ? 'Setting up audio connection...' :
                       'Waiting for connection...'}
                    </div>
                  </>
                )}
              </div>
            ) : (
              <div className="inputBar">
                <input
                  placeholder={loading ? 'One moment…' : `Message the ${activeRoleDef.label}`}
                  value={input}
                  onChange={e => setInput(e.target.value)}
                  onKeyDown={onKeyDown}
                  disabled={loading}
                />
                <button onClick={handleSend} disabled={loading || !input.trim()}>
                  {loading ? <><span className="spinner"></span> Sending…</> : 'Send'}
                </button>
              </div>
            )}
          </>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<ChatApp />);
    </script>
  </body>
</html>
